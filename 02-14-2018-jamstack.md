# JAMstack PWA - Up and Running with Gatsby.js, Firebase, and Netlify Pt. 1

In this two part tutorial, I'll show you how to get up and running with a progressive web application (PWA) that makes use of a powerful web architecture pattern called the JAMstack. We'll go through from initializing the project with linting and code formatting, to building out the UI of our application, and finally we'll deploy it to the web.

## What is JAMstack?

As defined on [jamstack.org](https://jamstack.org/):

> `JAMstack`: noun \’jam-stak’\
> Modern web development architecture based on client-side JavaScript, reusable APIs, and prebuilt Markup.

Paraphrased: JAMstack is a way of architecting your web applications with three key principals:

1. The client-side javascript handles all data fetching.
2. The APIs the client depend on, such as any databases, authentication services, asset CDNs, etc., are abstracted into CORS enabled microservices to be accessable from the client-side javascript.
3. Markup is prerendered at _build-time_, though not required, usually done with a static site generator.

## Cool story. But why?

### Performance

With the markup being rendered at build-time, there is no server runtime to generate the markup. The HTML files are already there ready to be sent over to the client. Granted the performance gains here aren't groundbreaking as most web server implementations utilize caching, but any gains to time to first byte is a plus.

### Cost

Again, since there's no server runetime and all that's being served are some static assets, the assets can be stored on and served from a CDN. Meaning costs to deploy your site are low and with some services like Netlify (which we'll cover later) can even be free.

### SEO

Search engines have an easier time crawling your website when markup is being served. This is not to say SPAs are not crawled by search engines, however, there are edge cases that make it difficult.

### Developer experience

With the backend services abstracted away into their own APIs, the front-end engineer has free reign over what tools, libraries, frameworks, languages, etc. to utilzie on the front-end. There are no restriction on what preprocessed languages or build tools can be used. Personally, I think the tools the node.js community have developed are second to none when it comes to DX. Tools like Webpack have enabled things like [Hot Module Replacement](https://webpack.js.org/concepts/hot-module-replacement/]). I know and love the development workflow node.js projects have to offer and often find myself longing for those tools when working on projects with what I consider inferior development tooling.

## About the app we're building

We'll be building a simple polling application. Authenticated users will be able to create a poll with some options that they in turn can share with a generated link. Users visiting that link can then choose one of the options and have their selection reflected on the results in real time.

## The Dev Stack

* [Gatsby.js](https://www.gatsbyjs.org/): Gatsby makes use of React.js to generate both the markup and javascript. It enables developers to fetch data from any data source and declaratively pull that data into their components using GraphQL.
* [Firebase firestore](https://firebase.google.com/products/firestore/): A noSQL cloud database that also exposes listerners for real time updates whenever data changes.
* [Firebase auth](https://firebase.google.com/products/auth/): To authenticate users via OAuth 2.
* [Netlify](https://www.netlify.com/): Netlify is a global CDN that makes continuous deployments as simple as a few clicks.
* [Prettier](https://prettier.io/): An opinionated code formatter.
* [ESLint](https://eslint.org/): Javascript linting.

All tools used in this tutorial are free or have an incredibly genereous free tier, so feel free to follow along.

## Getting Started

Let's get started! Install `gatsby-cli` globally, then run `gatsby new polling-app`, cd into, and initialize `git`.

`npm install --global gatsby-cli && gatsby new polling-app && cd polling-app && git init`

Let's now set up eslint. I generally like to just install [airbnb's](https://www.npmjs.com/package/eslint-config-airbnb) eslint config, then just override the rules I don't like.
Install airbnb's config and peer depedancies. If you're on Linux/OSX:

```
(
  export PKG=eslint-config-airbnb;
  npm info "$PKG@latest" peerDependencies --json | command sed 's/[\{\},]//g ; s/: /@/g' | xargs npm install --save-dev "$PKG@latest"
)
```

If you're on windows, head over to the link above and there will be directions on how to get those depeandcies installed.

Install other eslint peer-dependancies as well as prettier:
`npm install -D babel-eslint eslint-config-react eslint-config-prettier eslint-plugin-prettier prettier`

> -D specifies that these are development dependancies.

Add a `.eslintrc` file to the root of your project and paste in these rules. Anything you don't like, you can just override under `rules`.

```json
{
  "extends": ["airbnb", "prettier", "prettier/react"],
  "rules": {
    "react/jsx-filename-extension": [
      "error",
      { "extensions": [".js", ".jsx"] }
    ],
    "react/react-in-jsx-scope": 0,
    "react/require-default-props": 0,
    "no-shadow": 0,
    "consistent-return": 0,
    "no-console": 1,
    "no-case-declarations": 0,
    "import/prefer-default-export": 0
  },
  "plugins": ["prettier"],
  "settings": {
    "import/core-modules": ["react"]
  },
  "parser": "babel-eslint",
  "parserOptions": {
    "ecmaVersion": 2017,
    "sourceType": "module",
    "ecmaFeatures": {
      "jsx": true
    }
  },
  "env": {
    "es6": true,
    "browser": true,
    "node": true
  }
}
```

Do the same for a `.prettierrc` file:

```json
{
  "printWidth": 80,
  "singleQuote": true,
  "trailingComma": "all",
  "write": "src/**/*.js",
  "jsxBracketSameLine": true
}
```

Since we're specifying our own prettier rules, go to your `package.json` and remove the rules passed in as flags under `scripts.format`. Prettier will check for a `.prettierrc` file in the root of the project and use those rules.

`"format": "prettier --write \"src/**/*.{js,jsx}\""`

While we're at it, let's add a script for eslint:

`"lint": "eslint **/*.{js,jsx} --quiet"`

> --quiet flag specifies that only errors are to be reported, not warnings.
